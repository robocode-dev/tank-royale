name: Package Installers (jpackage)

permissions:
  contents: write
  actions: read

on:
  workflow_dispatch:
    inputs:
      version:
        description: "Release version (e.g., 1.2.3)"
        required: true
        type: string
  workflow_run:
    workflows: [ "Create Release" ]
    types:
      - completed

jobs:
  build-package:
    if: ${{ github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success' || !github.event.workflow_run.conclusion }}
    name: Build installers on ${{ matrix.os }}
    runs-on: ${{ matrix.os }}
    env:
      VERSION: ${{ github.event.inputs.version }}
    strategy:
      fail-fast: false
      matrix:
        os: [ ubuntu-latest, windows-latest, macos-latest ]

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Temurin JDK 21 (for jpackage)
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: '21'
          cache: 'gradle'

      - name: Set up Gradle
        uses: gradle/gradle-build-action@v3

      - name: Ensure WiX 3.x available (Windows)
        if: matrix.os == 'windows-latest'
        shell: powershell
        run: |
          $wix = Get-Command candle.exe -ErrorAction SilentlyContinue
          if ($wix) {
            Write-Host "WiX already available: $($wix.Path)"
            candle.exe -? | Select-Object -First 1
            exit 0
          } else {
            choco install wixtoolset -y --no-progress
          }

      - name: Install Linux packaging prerequisites
        if: matrix.os == 'ubuntu-latest'
        run: |
          sudo apt-get update
          sudo apt-get install -y rpm fakeroot libfuse2

      - name: Verify Java and jpackage
        run: |
          java -version
          jpackage --version

      - name: Build and create installers for this OS (quiet)
        run: |
          set -e
          # Ensure log directory exists
          mkdir -p build
          # Run Gradle quietly and capture all output to a log. On failure, print only the tail.
          ./gradlew --no-daemon --stacktrace --quiet --console=plain -Dorg.gradle.warning.mode=none stageAllInstallers \
            > build/ci-gradle.log 2>&1 \
            || (echo "Gradle build failed â€” showing last 400 lines of log:" && tail -n 400 build/ci-gradle.log && exit 1)
          echo "Gradle build succeeded. (Logs suppressed; see build/ci-gradle.log in the artifact if needed.)"
        shell: bash

      - name: Re-run macOS with deep jpackage diagnostics (only on macOS)
        if: matrix.os == 'macos-latest' && failure()
        run: |
          echo "Re-running macOS packaging with --debug to surface jpackage stderr"
          ./gradlew --no-daemon --debug -PciVerbose=true :booter:jpackageMac :recorder:jpackageMac
        shell: bash

      - name: Import GPG key (Linux/macOS)
        if: matrix.os != 'windows-latest'
        run: echo "$GPG_PRIVATE_KEY" | gpg --batch --import
        env:
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}

      - name: Import GPG key (Windows)
        if: matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          Set-Content -Path gpg-key.asc -Value $env:GPG_PRIVATE_KEY -NoNewline
          gpg --batch --import gpg-key.asc
        env:
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}

      - name: Generate SHA256 checksums (Linux/macOS)
        if: matrix.os != 'windows-latest'
        run: |
          cd build/dist
          find . -type f -exec sha256sum {} + > SHA256SUMS

      - name: Generate SHA256 checksums (Windows)
        if: matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          Set-Location build/dist
          Get-ChildItem -Recurse -File | ForEach-Object {
            $hash = Get-FileHash $_.FullName -Algorithm SHA256
            "$($hash.Hash)  $($_.FullName.Substring((Get-Location).Path.Length + 1))" | Out-File -Encoding ascii -Append SHA256SUMS
          }

      - name: Sign SHA256SUMS (Linux/macOS)
        if: matrix.os != 'windows-latest'
        run: |
          cd build/dist
          gpg --batch --yes --pinentry-mode loopback \
              --passphrase "$GPG_PASSPHRASE" \
              --armor --detach-sign SHA256SUMS
        env:
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}

      - name: Sign SHA256SUMS (Windows)
        if: matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          Set-Location build/dist
          gpg --batch --yes --pinentry-mode loopback --passphrase "$env:GPG_PASSPHRASE" --armor --detach-sign SHA256SUMS
        env:
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}

      - name: Upload installers
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: installers-${{ matrix.os }}
          path: |
            build/dist/**/*
            build/ci-gradle.log
            build/dist/SHA256SUMS
            build/dist/SHA256SUMS.asc
          if-no-files-found: warn

  upload-to-release:
    name: Upload installers to GitHub Release
    needs: build-package
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' || github.event_name == 'push' || github.event_name == 'workflow_run'
    steps:
      - name: Download all installer artifacts
        uses: actions/download-artifact@v4
        with:
          path: all-installers

      - name: List downloaded files (debug)
        run: |
          find all-installers

      - name: Ensure jq is available (required for URL encoding)
        run: |
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update && sudo apt-get install -y jq
          else
            echo "jq already installed"
          fi

      - name: Deduplicate SHA256SUMS files and remove build logs
        run: |
          # Keep only the first found SHA256SUMS and SHA256SUMS.asc
          find all-installers -name 'SHA256SUMS' | head -n 1 | xargs -I{} cp {} all-installers/SHA256SUMS
          find all-installers -name 'SHA256SUMS.asc' | head -n 1 | xargs -I{} cp {} all-installers/SHA256SUMS.asc
          # Remove all other SHA256SUMS and SHA256SUMS.asc
          find all-installers -name 'SHA256SUMS' ! -path 'all-installers/SHA256SUMS' -delete
          find all-installers -name 'SHA256SUMS.asc' ! -path 'all-installers/SHA256SUMS.asc' -delete
          # Remove ci-gradle.log files (debug logs not needed in release)
          find all-installers -name 'ci-gradle.log' -delete

      - name: Upload installers to GitHub Release
        run: |
          set -euo pipefail

          # Determine version from inputs or detect from latest release
          VERSION="${{ github.event.inputs.version }}"
          if [ -z "$VERSION" ]; then
            echo "No version provided via workflow_dispatch inputs. Attempting to detect from latest release..."
            VERSION=$(curl -sS -H "Authorization: token $GITHUB_TOKEN" \
              "https://api.github.com/repos/${{ github.repository }}/releases/latest" \
              | jq -r '.tag_name' | sed 's/^v//')
          fi

          if [ -z "$VERSION" ] || [ "$VERSION" == "null" ]; then
            echo "ERROR: Could not determine release version"
            exit 1
          fi

          TAG="v${VERSION}"
          echo "Working with release version: $VERSION (tag: $TAG)"

          # Import GPG key so we can sign a combined SHA256SUMS for ALL artifacts
          echo "$GPG_PRIVATE_KEY" > /tmp/gpg-key.asc
          gpg --batch --import /tmp/gpg-key.asc

          # Create combined SHA256SUMS from all downloaded artifacts (exclude existing SHA files)
          cd all-installers
          # Find files (exclude any existing SHA files) and produce a checksum list
          find . -type f ! -name 'SHA256SUMS*' -print0 | sort -z | xargs -0 sha256sum > SHA256SUMS

          # Sign the combined SHA256SUMS
          gpg --batch --yes --pinentry-mode loopback --passphrase "$GPG_PASSPHRASE" --armor --detach-sign SHA256SUMS

          # Return to the original directory
          cd ..

          # Get upload URL for the release
          # Note: We query all releases because draft releases may not be fetchable by tag
          API_URL="https://api.github.com/repos/${{ github.repository }}/releases"
          echo "Fetching releases from: $API_URL"
          echo "Looking for release with tag: $TAG"

          releases_response=$(curl -sS -H "Authorization: token $GITHUB_TOKEN" "$API_URL")

          # Find the release matching our tag (including draft releases)
          release_info=$(echo "$releases_response" | jq -r ".[] | select(.tag_name == \"$TAG\" or .name == \"$VERSION\")")

          if [ -z "$release_info" ]; then
            echo "ERROR: Could not find release with tag '$TAG' or name '$VERSION'"
            echo "Available releases:"
            echo "$releases_response" | jq -r '.[] | "\(.tag_name) - \(.name) (draft: \(.draft))"' | head -10
            exit 1
          fi

          upload_url=$(echo "$release_info" | jq -r .upload_url | sed -e 's/{.*//')
          release_id=$(echo "$release_info" | jq -r .id)
          is_draft=$(echo "$release_info" | jq -r .draft)

          if [ -z "$upload_url" ] || [ "$upload_url" == "null" ]; then
            echo "ERROR: Could not get upload URL for release"
            echo "Release info:"
            echo "$release_info" | jq .
            exit 1
          fi

          echo "Found release: ID=$release_id, tag=$TAG, draft=$is_draft"
          echo "Upload URL: $upload_url"

          # Helper to URI-encode strings (jq required)
          urlencode() { jq -nr --arg v "$1" '$v|@uri'; }

          # Upload function: uploads a file and sets a user-friendly asset name and label
          upload_asset() {
            local file_path="$1"
            local desired_name="$2"
            local label="$3"
            # determine MIME type
            mime=$(file --brief --mime-type "$file_path" || echo application/octet-stream)
            enc_label=$(urlencode "$label")
            # Upload via GitHub uploads API
            echo "Uploading $file_path as '$desired_name' (label: $label)"
            curl --fail -sS -X POST \
              -H "Authorization: token $GITHUB_TOKEN" \
              -H "Content-Type: $mime" \
              --data-binary @"$file_path" \
              "$upload_url?name=$(urlencode "$desired_name")&label=${enc_label}"
            echo
          }

          # Map files to human-friendly labels and corrected asset names
          while IFS= read -r -d '' f; do
            rel=${f#./}
            base=$(basename "$rel")

            # Default: upload with same name and a generic label
            asset_name="$base"
            label="${base}"

            # Fix common naming issues and set friendly labels
            case "$base" in
              robocode-tank-royale-gui-*.rpm)
                # Convert: name-version-release.arch.rpm -> name-version.arch.rpm (strip release)
                # Example: robocode-tank-royale-gui-0.34.2-1.x86_64.rpm -> robocode-tank-royale-gui-0.34.2.x86_64.rpm
                # Use perl with lookahead to only replace the '-<digits>.' that precedes the arch and .rpm
                asset_name=$(echo "$base" | perl -pe 's/-\d+\.(?=[^.]+\.rpm$)/./')
                 label="GUI for Linux (Red Hat Package Manager package)"
                ;;
              robocode-tank-royale-gui_*.deb)
                label="GUI for Linux (Debian package)"
                ;;
              *.msi)
                label="GUI for Windows (MSI)"
                ;;
              Robocode.Tank.Royale.GUI-*.pkg)
                # Ensure package name uses release version rather than packaging internal version
                # Replace embedded version with release version input if different
                asset_name="Robocode.Tank.Royale.GUI-${VERSION}.pkg"
                label="GUI for macOS"
                ;;
              *GUI*.jar)
                label="GUI (jar)"
                ;;
              *Server*.jar)
                label="Server (jar)"
                ;;
              *)
                # Detect sample-bots archives by name inspection
                lower=$(echo "$base" | tr '[:upper:]' '[:lower:]')
                if [[ "$lower" == *sample* && ( "$lower" == *csharp* || "$lower" == *cs* ) ]]; then
                  label="Sample bots for C# (zip)"
                elif [[ "$lower" == *sample* && "$lower" == *java* ]]; then
                  label="Sample bots for Java (zip)"
                elif [[ "$lower" == *sample* && ( "$lower" == *python* || "$lower" == *py* ) ]]; then
                  label="Sample bots for Python (zip)"
                fi
                ;;
            esac

            upload_asset "$f" "$asset_name" "$label"
          done < <(find all-installers -type f -print0)

          # Finally upload the combined checksums and signature
          upload_asset "all-installers/SHA256SUMS" "SHA256SUMS" "SHA256 checksums"
          upload_asset "all-installers/SHA256SUMS.asc" "SHA256SUMS.asc" "Signed SHA256 checksums (ASCII-armored)"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
          shell: bash

